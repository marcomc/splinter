#!/bin/bash
set -e # Exit immediately if anything returns a non-zero status.
version="0.6.1-beta"
release_date="20200912"
my_name="$(basename "$0")"
start_time=$(date +%s)

splinter_config_file="splinter.cfg"

python_provider="conda"
pip_dependecies="ansible wheel passlib"
conda_package_name="splinter-conda.tar.gz"
conda_package_version="v0.1"
conda_package_url="https://github.com/marcomc/splinter-conda/releases/download/${conda_package_version}/${conda_package_name}"

desired_ansible_version='2.9.13'
desired_passlib_version='1.7.2'
desired_python_version='3.8.5'
desired_wheel_version='0.35.1'

homebrew_installer_url='https://raw.githubusercontent.com/Homebrew/install/master/install.sh'

pause_seconds='3'
staff_guid='20'

splinter_archive_url="https://github.com/marcomc/splinter/archive/master.zip"
splinter_tools_url="https://github.com/marcomc/splinter-tools/archive/master.zip"

function _exec {
  "$@" || { _echo "Failed during: $*" 'e'; exit 1; }
}

function abs_path {
  local file="$1"
  local absolute_path=""
  directory=$(dirname "$file")
  # shellcheck disable=SC2001 # can't avoid the use of sed
  directory=$(echo "$directory" | sed 's+~+'"${HOME}"'+g' )
  absolute_path="$(cd "$directory"|| exit 1; pwd )"
  echo "${absolute_path}/$(basename "$file")"
}
function _error {
  printf "[Error] %s\n" "$1" 1>&2
  printf "\n(Type 'splinter --help' for usage instructions)\n" 1>&2
}

if ! command -v "pv" >/dev/null 2>&1; then
  # if pv is not installed we declare a function that bypass stdin
  function pv { cat; }
fi

function _echo {
  local bright="0"
  local purple="35"
  local red="31"
  local green="32"
  local cyan="36"
  local white="39"
  local yellow="33"
  local color="$white"
  local extra_text_color="\e[1;${white}m"
  local message_after_colum=""
  local message_before_colum=""
  local message_type=""
  local message_type=""
  local normal_text_color="\e[0;${white}m"
  local output_device="/dev/stdout"
  local tag_color=""
  local tag=""

  message="$1"
  case $2 in
    a|action)
      color="$green"
      bright="1"
      tag='ACTION..'
    ;;
    w|warning)
      color="$purple"
      bright="1"
      tag='WARNING.'
      message_type="warning"
      output_device="/dev/stderr"
      ;;
    e|error)
      color="$red"
      bright="1"
      tag='ERROR...'
      message_type="error"
      output_device="/dev/stderr"
      ;;
    r|remark)
      color="$cyan"
      bright="1"
      tag='SPLINTER'
    ;;
    i|info|*)
      message_type="info"
      color="$yellow"
      bright="2"
      tag='INFO....'
    ;;
  esac
  tag_color="\e[${bright};${color}m"

  if [[ $message_type == 'info' ]] && [[ -n ${message//[^:]/} ]]; then
    message_before_colum="${message%': '*}"
    message_after_colum="${message#*': '}"
  else
    message_before_colum="$message"
    message_after_colum=""
  fi

  if [[ $verbose == 'yes' ]] || [[ $message_type != 'info' ]]; then
    if [[ $quiet == 'no' ]] || [[ $message_type == 'error' ]] || [[ $message_type == 'warning' ]]; then
      printf "${tag_color}[$tag] ${normal_text_color}%s${extra_text_color} %s${normal_text_color}\n" "$message_before_colum" "$message_after_colum" > "$output_device"
    fi
  fi
}

function show_version {
  echo "Splinter $version $release_date"
}

function show_title {
printf "\e[1;39m"
  cat << 'EOF'
   _______  _____         _____ __   _ _______ _______  ______
   |______ |_____] |        |   | \  |    |    |______ |_____/
   ______| |       |_____ __|__ |  \_|    |    |______ |    \_
EOF
printf "\e[0;39m"
cat << 'EOF'
        2020 (c) MarcoMC - github.com/marcomc/splinter
An opinionated provisioning tool for macOS automated with Ansible

EOF
}

function show_usage {
printf  "usage: %s [option] action [object] [settings]\n" "$my_name"
cat << 'EOF'

options:
       -e|--env conda|pyenv|none  Chose the Python environemnt
       -v|--verbose               Produce verbose output
       -q|--quiet                 Suppress all non-Ansible output (except errors and warnings)
       --help                     Print help
       --version                  Print Splinter version and release date

actions:
       create <object> [settings]
       list profiles              List available profiles
       provision [settings]       Provision the host
       update <object>            Update the <object>
       export <object> [settings] Export list of <object> packages

objects:
       [ create ]
       package [settings]         Create distributable package of your splinter project
       filevault-recovery-key     Create a FileVaultMaster recovery key in both Keychain and DER formats

       [ export ]
       preferences                    Export system preferences and user's dorfiles using Macprefs
       brew [taps|packages|casks|all] Export list of brew taps, packages and casks
       ruby [gems]                    Export list of user installed Ruby gems
       mas [packages]                 Export list of installed apps from MacAppStore
       npm [packages]                 Export list of NPM packages
       pip [packages]                 Export list of user installed Python packages from Pip
       all                            Export all the above

       [ update ]
       conda                      Reinstall the most recent Miniconda Python environment available for splinter
       pyenv                      Reinstall Pyenv Python environment
       galaxy|galaxy-roles        Force update all the Ansible Galaxy roles
       tools                      Update the splinter tools
       deps|dependencies          Update all the dependencies (Python envs and  Ansible Galaxy role)
       self|auto|splinter         Update Splinter itself (but not the tools or dependencies)
       profiles [settings]        Update the profiles from a online git repo (for now only github is supported)

settings:
       [ provision ]
       -c file                    Specify a custom configuration file
       -u username                New user username (all lowercase  without spaces)
       -f 'Full Name'             New user full name (quoted if has blank spaces)
       -p 'cleartext password'    New user's password in cleartext (quoted if has blank spaces)
       -t username                Target user username, if different than the new user (can be used to provision the current account)
       -h Computer-Name           Computer host name no blank spaces allowed

       [ provision, update profiles ]
       -a account_name            Specify the the Github account name for the custom `splinter-profiles` repo
       -g git-repo-name           Specify the the Github repository name for the custom `splinter-profiles` repo
       -b profile_name            Specify the the BASE profile to be used (default: 'base')
       -r profile_name            Specify the the ROLE profile to be used

       [ create package ]
       -n Package-Name            The name of the package (without extension)
       -d path/to/directory       The destination directory where to place the package
       -t dmg|zip                 The type of package

EOF
  printf  "Create your own profiles in the project's profiles directory.\n"
}

function locate_config_file {
    if [[ $splinter_config_file != "$(basename $splinter_config_file)" ]]; then
      # if the config file has been declared WITH a path we expand the path
      splinter_config_file="$(abs_path $splinter_config_file)"
    else
      user_path=$(pwd)
      # if the config file has been declared WITHOUT a path
      if [[ -f ${user_path}/${splinter_config_file} ]]; then
        # we check if it exists in the current directory
        splinter_config_file_dir="$user_path"
      else
        # assumes the directory that contains the `splinter` script is the Splinter directory
        splinter_config_file_dir="$(abs_path "$(dirname "$0")")"
        splinter_config_file_dir="${splinter_config_file_dir%"/."}" # remove training '/.' if any
      fi
      splinter_config_file="${splinter_config_file_dir}/${splinter_config_file}"
    fi
}

function setup_environment {
  # This order must be respected
  export_envs         # step 1
  set_app_directories # step 2
  export_ansible_envs # step 3
}

function export_envs {
  locate_config_file
  if [[ -n $splinter_config_file ]] && [[ -f $splinter_config_file ]]; then
    # if a config file exist we will check the environemnts one by one
    # if no value comes from the command line we will load the value in the config
    [[ -z $verbose ]] && verbose=$(read_ini_value 'verbose')
    [[ -z $SPLINTER_PROJECT_DIR ]] && SPLINTER_PROJECT_DIR=$(read_ini_value 'project_dir') && export SPLINTER_PROJECT_DIR
    [[ -z $SPLINTER_BASE_PROFILE ]] && SPLINTER_BASE_PROFILE=$(read_ini_value 'base_profile') && export SPLINTER_BASE_PROFILE
    [[ -z $SPLINTER_ROLE_PROFILE ]] && SPLINTER_ROLE_PROFILE=$(read_ini_value 'role_profile') && export SPLINTER_ROLE_PROFILE
    [[ -z $custom_profiles_repo_account ]] &&  custom_profiles_repo_account=$(read_ini_value 'custom_profiles_account')
    [[ -z $CUSTOM_PROFILES_REPO ]] && CUSTOM_PROFILES_REPO=$(read_ini_value 'custom_profiles_repo') && export CUSTOM_PROFILES_REPO
    [[ -z $NEW_USER_USERNAME ]] && NEW_USER_USERNAME=$(read_ini_value 'new_user_username') && export NEW_USER_USERNAME
    [[ -z $NEW_USER_FULL_NAME ]] && NEW_USER_FULL_NAME=$(read_ini_value 'new_user_fullname') && export NEW_USER_FULL_NAME
    [[ -z $NEW_USER_PASSWORD_CLEARTEXT ]] && NEW_USER_PASSWORD_CLEARTEXT=$(read_ini_value 'new_user_password_cleartext') && export NEW_USR_PASSWORD_CLEARTEXT
    [[ -z $TARGET_USER_ID ]] && TARGET_USER_ID=$(read_ini_value 'target_user_username') && export TARGET_USER_ID
    [[ -z $COMPUTER_HOST_NAME ]] && COMPUTER_HOST_NAME=$(read_ini_value 'computer_name') && export COMPUTER_HOST_NAME
  fi
  if [[ -z $SPLINTER_PROJECT_DIR ]]; then
    SPLINTER_PROJECT_DIR=$(dirname "$splinter_config_file")
    export SPLINTER_PROJECT_DIR
  fi

  if [[ -n $NEW_USER_USERNAME ]]; then
    export CREATE_NEW_USER='yes'
    [[ -z $TARGET_USER_ID ]] && export TARGET_USER_ID="$NEW_USER_USERNAME"
  else
    export CREATE_NEW_USER='no'
  fi
  export VERBOSE="$verbose"
}

function export_ansible_envs {
    export ANSIBLE_CONFIG="$ansible_config"
    export ANSIBLE_ROLES_PATH="$ansible_roles"
}

function show_envs {
  _echo "$(show_version)"
  _echo "action: $action $action_option"
  _echo "VERBOSE: $VERBOSE"
  [[ -n $SPLINTER_PROJECT_DIR ]]          && _echo "SPLINTER_PROJECT_DIR: $SPLINTER_PROJECT_DIR"
  [[ -n $splinter_config_file ]]         && _echo "SPLINTER_CONFIG_FILE: $splinter_config_file"
  [[ -n $SPLINTER_BASE_PROFILE ]]        && _echo "SPLINTER_BASE_PROFILE: $SPLINTER_BASE_PROFILE"
  [[ -n $SPLINTER_ROLE_PROFILE ]]        && _echo "SPLINTER_ROLE_PROFILE: $SPLINTER_ROLE_PROFILE"
  [[ -n $custom_profiles_repo_account ]] && _echo "CUSTOM_PROFILES_REPO_ACCOUNT: $custom_profiles_repo_account"
  [[ -n $CUSTOM_PROFILES_REPO ]]         && _echo "CUSTOM_PROFILES_REPO: $CUSTOM_PROFILES_REPO"
  [[ -n $CREATE_NEW_USER ]]              && _echo "CREATE_NEW_USER: $CREATE_NEW_USER"
  [[ -n $NEW_USER_USERNAME ]]            && _echo "NEW_USER_USERNAME: $NEW_USER_USERNAME"
  [[ -n $NEW_USER_FULL_NAME ]]           && _echo "NEW_USER_FULL_NAME: $NEW_USER_FULL_NAME"
  [[ -n $NEW_USER_PASSWORD_CLEARTEXT ]]  && _echo "NEW_USER_PASSWORD_CLEARTEXT: $NEW_USER_PASSWORD_CLEARTEXT"
  [[ -n $TARGET_USER_ID ]]               && _echo "TARGET_USER_ID: $TARGET_USER_ID"
  [[ -n $COMPUTER_HOST_NAME ]]           && _echo "COMPUTER_HOST_NAME: $COMPUTER_HOST_NAME"
  [[ -n $ANSIBLE_CONFIG ]]               && _echo "ANSIBLE_CONFIG: $ANSIBLE_CONFIG"
  [[ -n $ANSIBLE_ROLES_PATH ]]           && _echo "ANSIBLE_ROLES_PATH: $ANSIBLE_ROLES_PATH"
}

function print_execution_time {
  start_seconds="$1"
  end_seconds=$(date +%s)
  total_seconds=$(( end_seconds - start_seconds ))
  total_minutes=$(( total_seconds / 60 ))

  if [[ $total_minutes -gt 0 ]]; then
    total="${total_minutes} minutes"
  else
    total="${total_seconds} seconds"
  fi
  _echo "Execution time was $total" 'r'
}

function read_ini_value {
  if [[ -n $1 ]]; then
    parameter="$1"
  else
    _echo "No parameter specified to read from the ini file '$splinter_config_file'" 'e'
    exit 1
  fi

  if [[ ! -f $splinter_config_file ]]; then
    _echo "The config file '$splinter_config_file' is not present" 'e'
    exit 1
  else
    # _echo "Reading parameter '$parameter' from config file"
    awk -F '=' '{gsub(/"/, "", $0); if (! ($0 ~ /^;/) && $0 ~ /'"${parameter}"'/) print $2}' "$splinter_config_file"
  fi
}

function set_app_directories {
  project_dir="$(abs_path "$SPLINTER_PROJECT_DIR")"

  files_path="${project_dir}/files"
  lists_path="${files_path}/lists"
  certificates_path="$files_path/certificates"
  preferences_path="${files_path}/preferences"

  tools_path="${project_dir}/tools"
  profiles_path="${project_dir}/profiles"
  ansible_dir="${project_dir}/ansible"
  pyenv_dir="${project_dir}/pyenv"
  conda_path="${project_dir}/conda"
  pip_config_file="${project_dir}/pip.conf"

  ansible_roles="${ansible_dir}/roles"
  ansible_config="${ansible_dir}/ansible.cfg"
  ansible_inventory="${ansible_dir}/inventory"
  ansible_playbook="${ansible_dir}/playbook.yml"
  ansible_requirements="${ansible_dir}/requirements.yml"

  tools_script_export_apps_lists="${tools_path}/export-apps-lists.sh"
  tools_script_create_recovery_key="${tools_path}/filevault-recovery-key-generator.sh"
  tools_script_export_system_preferences="${tools_path}/backup-system-preferences.sh"
  tools_macprefs_path="${tools_path}/macprefs"

}

function update_splinter {
  local temp_dir
  temp_dir=$(mktemp -d)
  splinter_archive="${my_name}.zip"

  _echo "Updating Splinter" 'a'

  _echo "Downloading Splinter into '${temp_dir}/${splinter_archive}'" 'a'
  _exec "curl" "-H" "'Cache-Control: no-cache'" "-fsSL" "$splinter_archive_url" "-o" "${temp_dir}/${splinter_archive}"

  _echo "Decompressing Splinter archive into '$temp_dir'" 'a'
  _exec "unzip" "-qq" "${temp_dir}/${splinter_archive}" "-d" "${temp_dir}"
  ls "$temp_dir"

  _echo "Installing Splinter files to '$project_dir'" 'a'
  _exec "rsync" "--exclude" ".git" "--exclude" ".gitmodules" "--exclude" ".gitignore" "--exclude" ".travis.yml" "--exclude" "tests/" "-rlWuv" "$temp_dir"/*/* "$project_dir"

  _echo "Removing temporary files" 'a'
  _exec "rm" "-rf" "$temp_dir"

  _echo "Update successful!" 'r'
}

function update_tools {
  _echo "Updating Splinter tools" 'a'
  splinter_tools_archive="${my_name}-tools.zip"
  temp_dir=$(mktemp -d)

  _echo "Downloading Splinter tools into '$temp_dir}/${splinter_tools_archive}'" 'a'
  _exec "curl" "-H" "'Cache-Control: no-cache'" "-fsSL" "$splinter_tools_url" "-o" "${temp_dir}/${splinter_tools_archive}"

  _echo "Decompressing Splinter tools into '$temp_dir'" 'a'
  _exec "unzip" "-qq" "${temp_dir}/${splinter_tools_archive}" "-d" "$temp_dir"

  _echo "Installing Splinter tools to '$tools_path'" 'a'
  _exec "rsync" "-rlWuv" "--exclude" ".git" "--exclude" ".gitmodules" "--exclude" ".gitignore" "--exclude" ".travis.yml" "--exclude" "tests/" "$temp_dir"/*/* "$tools_path"
  if [[ -x "$tools_script_export_system_preferences" ]]; then
    _exec "$tools_script_export_system_preferences" "-m" "$tools_macprefs_path" "install"
  fi

  _echo "Removing temporary files" 'a'
  _exec "rm" "-rf" "$temp_dir"

  _echo "Tools updated successfully!" 'r'
}

function update_profiles {
  if [[ -z $custom_profiles_repo_account ]]; then
    _echo "No account name was provided to update the profiles from a repository. Use '-a <account_name>' option" 'e'
    exit 1
  fi

  if [[ $VERBOSE == 'no' ]]; then
    quiet_rsync='yes'
  else
    quiet_rsync=""
  fi
  profile_name="$1"
  profile_to_single_out="$profile_name"
  if [[ -n ${profile_name//[^.]/} ]]; then
    # isolate the actual profile name located after the `.`
    profile_to_single_out="${profile_name#*"."}"
  fi

  target_profile_name="${custom_profiles_repo_account}.${profile_to_single_out}"
  if [[ -n $CUSTOM_PROFILES_REPO ]]; then
    repository="$CUSTOM_PROFILES_REPO"
  else
    repository="splinter-profiles";
  fi
  exclude_dir="files"
  splinter_profiles_source_site="https://www.github.com"
  splinter_profiles_archive="${custom_profiles_repo_account}-profiles.zip"
  splinter_profiles_url="${splinter_profiles_source_site}/${custom_profiles_repo_account}/${repository}/archive/master.zip"
  temp_dir=$(mktemp -d)

  _echo "Updating profiles and files from custom repository" 'a'

  _echo "Downloading custom profiles into '${temp_dir}/${splinter_profiles_archive}'" 'a'
  _exec "curl" "-H" "'Cache-Control: no-cache'" "-fsSL" "$splinter_profiles_url" "-o" "${temp_dir}/${splinter_profiles_archive}"

  _echo "Decompressing custom profiles into '$temp_dir'" 'a'
  _exec "unzip" "-qq" "${temp_dir}/$splinter_profiles_archive" "-d" "$temp_dir"

  # Rename each single 'profile' to 'account.profile' format
  find "$temp_dir"/* ! -path "*files" "-maxdepth" "1" "-mindepth" "1" -type directory -exec sh -c 'mv $2 "$(dirname $2)/$1.$(basename $2)" ' -- "$custom_profiles_repo_account" {} \;

  if [[ $profile_to_single_out != '' ]]; then

    temp_profilepath="$(find "$temp_dir" -type directory -name "$target_profile_name")"

    if [[ -d $temp_profilepath ]];then
      _echo "Installing custom profile '$target_profile_name' to '$profiles_path'" 'a'
      _exec "rsync" "-rlWuv${quiet_rsync}" "--delete" "--exclude" "$exclude_dir" "$temp_profilepath" "${profiles_path}/"
    else
      _echo "No profile '$target_profile_name' found in '$splinter_profiles_url'" 'e'
      exit 1
    fi
  else
    _echo "Installing custom profiles to '$profiles_path'" 'a'
    _exec "rsync" "-rlWuv${quiet_rsync}" "--exclude" "$exclude_dir" "$temp_dir"/*/* "$profiles_path"
  fi

  _echo "Installing custom files to '$files_path'" 'a'
  _exec "rsync" "-rlWuv$quiet_rsync" "$temp_dir"/*/files/* "$files_path"

  _echo "Removing temporary files" 'a'
  _exec "rm" "-rf" "$temp_dir"

  _echo "Profiles updated successfully!" 'r'
}

function create_package {
  local temp_dir
  local project_dir_number_of_files
  local rsync_failed
  local source_dir

  [[ $package_type == "" ]] && package_type="dmg"
  [[ $package_name == "" ]] && package_name="SplinterProvision"
  [[ $package_destination == "" ]] && package_destination="$project_dir"

  if [[ ! -d $package_destination ]]; then
    _echo "Cannot find the destination directory '$package_destination'" 'e'
    exit 1
  fi

  local package_output="${package_destination}/${package_name}.${package_type}"

  if [[ -f $package_output ]]; then
    _echo "The package '$package_output' already exists" 'e'
    _echo "Delete the old package before proceeding" 'e'
    exit 1
  fi

  [[ -n $SPLINTER_BASE_PROFILE ]] && retrieve_profile "$SPLINTER_BASE_PROFILE"
  [[ -n $SPLINTER_ROLE_PROFILE ]] && retrieve_profile "$SPLINTER_ROLE_PROFILE"
  install_dependencies

  project_dir_number_of_files=$(find "$project_dir" -not -name ".gitignore" -not -path '*/\.git*' -not -name "*.dmg" -not -name "*.zip" -not -name ".DS_Store" |wc -l)
  temp_dir=$(mktemp -d)

  [[ $package_type != "" ]] && _echo "package_type: $package_type"
  [[ $package_name != "" ]] && _echo "package_name: $package_name"
  [[ $package_destination != "" ]] && _echo "package_destination: $package_destination"

  source_dir="${temp_dir}/${package_name}"
  _echo "TEMP_DIR: $source_dir"
  mkdir -p "$source_dir"

  _echo "Copying the project files into the temporary directory" 'a'
  rsync -rlWuv \
        --exclude ".git" \
        --exclude ".gitignore" \
        --exclude ".DS_Store" \
        --exclude "*keychain-password.txt" \
        "$project_dir"/* \
        "$source_dir" | pv -ples "$project_dir_number_of_files"  > /dev/null || rsync_failed="true"

  if [[ $rsync_failed == "true" ]]; then
    _echo "Copying the project files failed" 'e'
    exit 1
  fi

  bundle_package "$package_type" "$source_dir" "$package_output"

  _echo "Removing temporary files" 'a'
  _exec "rm" "-rf" "$temp_dir"
  _echo "Archive '$package_output' created successfully" 'r'
}

function bundle_package {
  if [[ "$1" == "" || "$2" == "" || "$2" == "" ]]; then
    echo "'bundle_package' called with not enough parameters"
    exit
  fi

  local package_type="$1"
  local source_dir="$2"
  local package_output="$3"
  local source_project_dir

  source_dir_number_of_files=$(find "$source_dir" | wc -l)
  source_project_dir=${source_dir%%+(/)}    # trim however many trailing slashes exist
  source_project_dir=${source_project_dir##*/}       # remove everything before the last / that still remains

  case $package_type in
    zip)
      _echo "Creating the ZIP package '$package_output'" 'a'
      _exec "cd" "${source_dir}/.."
      zip -r --symlinks \
          -X "$package_output" \
          "$source_project_dir" | pv -ples "$source_dir_number_of_files"  > /dev/null || zipping_failed="true"

      if [[ $zipping_failed == "true" ]]; then
        _echo "Zipping the project files failed" 'e'
        exit 1
      fi
    ;;
    dmg|*)
      _echo "Creating the Disk Image '$package_output'" 'a'
      _exec "hdiutil" "create" "$package_output" "-ov" "-volname" "package_name" "-fs" "HFS+" "-srcfolder" "$source_dir"
    ;;
  esac
}

function check_install_path_permissions {
  current_path="$(pwd -P)"
  third_level_dir=$(echo "$current_path"| cut -d'/' -f-4)
  dir_stats=$(stat -f '%N %g %p' "$third_level_dir")
  read -ra DIR_STATS <<< "$dir_stats"
  dir_name="${DIR_STATS[0]}"
  dir_group_id="${DIR_STATS[1]}"
  dir_pemissions="${DIR_STATS[2]:(-3)}"
  dir_group_pemissions="${DIR_STATS[2]:(-2):1}"

  if [[ $current_path == "$HOME" ]]; then
    _echo 'You are running this script within your home directory' 'w'
    _echo 'Ansible might fail if your home directories are protected' 'w'
    _echo "(not allowing group memebers to 'read' AND 'exec' them)" 'w'
    _echo "Checking the permissions on the containing dir" 'a'
    _echo "DIR_NAME: $dir_name"
    _echo "dir_group_id: $dir_group_id"
    _echo "DIR_PEMISSIONS: $dir_pemissions"
    if [[ $staff_guid != "$dir_group_id" ]]; then
      _echo "The '$dir_name' group is not 'staff($staff_guid)'" 'w'
    elif [[ $dir_group_pemissions -lt 5 || $dir_group_pemissions -eq 6 ]]; then
      _echo "'$dir_name' does NOT allow the 'staff' group to 'read' AND 'exec'" 'w'
      _echo "(this might lead to issues during the execution of some Ansible tasks)" 'w'
      _echo "Adding POSIX 'g+rx' permissions to $third_level_dir" 'a'
      _exec "chmod" "g+rx" "$third_level_dir"
      export ORIGINAL_DIR_PEMISSIONS="$dir_pemissions"
      export THIRD_LEVEL_DIR="$third_level_dir"
    fi
    if [[ $quiet == 'no' ]]; then
      _echo "Pausing for $pause_seconds seconds for you to read the above message..." 'a'
      printf ">>>>>>>>>> "
      for ((i=1; i<=pause_seconds; i++)); do
        # running the countdown before resuming operations
        printf "..%s" "$i"
        sleep 1
      done
      printf "\n" # add newline after the countdown
    fi
  fi
}

function restore_path_permissions {
  if [[ -n $ORIGINAL_DIR_PEMISSIONS ]] && [[ -n $THIRD_LEVEL_DIR ]]; then
    _echo "Restoring original permissions '$ORIGINAL_DIR_PEMISSIONS' to the directory '$THIRD_LEVEL_DIR'" 'a'
    chmod "$ORIGINAL_DIR_PEMISSIONS" "$THIRD_LEVEL_DIR"
  fi
}

function retrieve_profile {
  requested_profile="$1"
  _echo "profiles_path: $profiles_path"
  _echo "requested_profile: $requested_profile"
  if [[ -z $requested_profile ]]; then
    _echo "No profile name has been provided" 'e'
    exit 1
  elif [[ -d ${profiles_path}/${requested_profile} ]] && [[ $action != 'update' ]]; then
    _echo "The profile '$requested_profile' is already installed"
  else
    if [[ -n ${requested_profile//[^.]/} ]]; then
      # if the profile name is contains a '.'
      #we just talke the first part of the name as the git repo custom_profiles_repo_account
      custom_profiles_repo_account="${requested_profile%"."*}"
    fi

    if [[ -n $custom_profiles_repo_account ]]; then
      update_profiles "${requested_profile}"
    else
      [[ $action != 'update' ]] && _echo "The profile '$requested_profile' not found in '$profiles_path'" 'e'
      _echo "No account name was provided to fetch '$requested_profile' from a repository. Use '-a <account_name>' option" 'e'
      exit 1
    fi
  fi
}

function enable_passwordless_sudo {
  sudo_stdin=''
  if sudo -n true 2>/dev/null; then
    _echo "Passwordless sudo seems to be already enabled"
  else
    if [[ -n "$ANSIBLE_BECOME_PASS" ]]; then
      sudo_stdin='--stdin'
    fi
    # Enable passwordless sudo for the provisioning
    _echo "Enabling passwordless sudo for the provisioning" 'a'
    echo "$ANSIBLE_BECOME_PASS" | sudo "$sudo_stdin" sed -i -e "s/^%admin .*ALL=.*/%admin ALL=(ALL) NOPASSWD: ALL/" /etc/sudoers > /dev/null 2>&1
  fi
}

function disable_passwordless_sudo {
  if sudo -n true 2>/dev/null; then
    # Enable passwordless sudo for the provisioning
    _echo "Disabling passwordless sudo after the provisioning" 'a'
    sudo sed -i -e "s/^%admin .*ALL=.*/%admin ALL=(ALL) ALL/" /etc/sudoers
  else
    _echo "Passwordless sudo is disabled"
  fi
}

function install_pip_dependencies {
  pip_show_grep_filter='Version'  # 'Name\|Version\|Location' - it's a grep filter
  for pip_dependecy in $pip_dependecies; do
    if ! pip show "$pip_dependecy" > /dev/null 2>&1; then
      _echo "$pip_dependecy not installed" w
      eval "install_pip_${pip_dependecy}"
    else
      dep_version=$(pip show "$pip_dependecy" | grep "$pip_show_grep_filter")
      _echo "$pip_dependecy $dep_version is installed "
    fi
  done
}

function install_brew {
  if ! command -v "brew" >/dev/null 2>&1; then
    _echo "Installing Homebrew" 'a'
    /bin/bash -c "$(curl -fsSL $homebrew_installer_url)" < /dev/null
  else
    tool_version=$(command -v "brew")
    _echo "Homebrew $tool_version is installed"
  fi

}

function install_conda {
  conda_package_path="${files_path}/${conda_package_name}"
  if [[ $reinstall_conda == 'yes' ]];then
    if [[ -f $conda_package_path ]]; then
      _echo "Removing old Miniconda Python package '$conda_package_path'" 'a'
      _exec "rm" "${conda_package_path}"
    fi
    if [[ -d $conda_path ]]; then
      _echo "Removing old Miniconda Python directory '$conda_path'" 'a'
      _exec "rm" "-rf" "${conda_path}"
    fi
  fi
  if [[ ! -d ${conda_path}/bin ]];then
    if [[ ! -f $conda_package_path ]];then
      _echo "Downloading Miniconda Python package to '$conda_package_path'" 'a'
      _exec "curl" "-H" "'Cache-Control: no-cache'" "-fsSL" "$conda_package_url" "-o" "$conda_package_path"
    fi
    _echo "Unpacking Miniconda Python package to '$conda_path' directory" 'a'
    _exec "mkdir" "-p" "$conda_path"
    _exec "tar" "-xzf" "$conda_package_path" "-C" "$conda_path"
  else
    _echo "Miniconda Python package is already installed in '$conda_path' directory" 'i'
  fi
}

function activate_conda {
  _echo "USING PROJECT'S OWN MINICONDA PYTHON VERSION" 'r'

  # Actual Conda activation
  python_root="${conda_path}"
  export _CONDA_ROOT="${conda_path}"
  export CONDA_PREFIX="${_CONDA_ROOT}"
  export PATH="${_CONDA_ROOT}/bin:$PATH"

  _echo "Cleanup prefixes from in the active environment"
  _exec "conda-unpack"

  python_version="$(python --version 2>&1)"
  _echo "${python_version} is installed"

  # Fix issues with SSL Certificates
  cert_path=$(python -m certifi)
  export SSL_CERT_FILE="$cert_path"
  export REQUESTS_CA_BUNDLE="$cert_path"
  _echo "SSL_CERT_FILE: $cert_path"
  _echo "REQUESTS_CA_BUNDLE: $cert_path"

}

function activate_pyenv {
  _echo "USING PROJECT'S OWN PYENV PYTHON VERSION" 'r'
  export PYENV_ROOT="$pyenv_dir"
  export PATH="${PYENV_ROOT}/bin:${PATH}"
  export PYENV_VERSION="$desired_python_version"
  python_root="$pyenv_dir"
  _echo "PYENV_ROOT: $PYENV_ROOT"
  _echo "PYTHON_VERSION: $(pyenv version)"
}

function update_brew {
  _echo "Updating Homebrew" 'a'
  _exec "brew" "update"
}

function install_pyenv {
  if ! command -v "pyenv" >/dev/null 2>&1; then
    _echo "Installing Pyenv" 'a'
    # install pyenv with homebrew
    update_brew
    _exec "brew" "install" "pyenv"
  else
    tool_version=$(command -v "pyenv")
    _echo "Pyenv $tool_version is installed"
  fi
}

function install_pip_ansible {
  _echo "PIP - Installing Ansible $desired_ansible_version" 'a'
  _exec "pip" "install" "ansible==${desired_ansible_version}"
}

function install_pip_wheel {
  _echo "PIP - Installing Wheel $desired_wheel_version" 'a'
  _exec "pip" "install" "wheel==${desired_wheel_version}"
}

function install_pip_passlib {
  _echo "PIP - Installing passlib $desired_passlib_version" 'a'
  _exec "pip" "install" "passlib==${desired_passlib_version}"
}

function install_pyenv_python {
  if [[ $reinstall_pyenv == 'yes' ]]; then
    if [[ -d $pyenv_dir ]]; then
      _echo "Removing old Pyenv Python directory '$pyenv_dir'" 'a'
      _exec "rm" "-rf" "$pyenv_dir"
    fi
  fi
  if ! pyenv versions | grep "$desired_python_version" > /dev/null 2>&1; then
    # â€¢	install python3 with pyenv
    _echo "Installing Pyenv Python $desired_python_version" 'a'
    _exec "pyenv" "install" "$desired_python_version"
    _exec "ln" "-fs" "shims" "${pyenv_dir}/bin"
    _echo "Rehashing Pyenv Python shims $desired_python_version" 'a'
    _exec "pyenv" "rehash"
  else
    _echo "Pyenv Python $desired_python_version is already installed"
  fi
}

function upgrade_pip {
    _echo "Upgrading PIP to the latest version" 'a'
    _exec "pip" "install" "--upgrade" "pip"
}

function install_ansible {
  if ! command -v 'ansible' >/dev/null 2>&1; then
    _echo "Ansible not installed" w
    install_pip_ansible
  else
    _echo "Ansible is already installed"
    _exec "ansible" "--version"
  fi
}

function install_ansible_galaxy_roles {

  if [[ $verbose == 'yes' ]];then
    dev_output="/dev/stdout"
  else
    dev_output="/dev/null"
  fi
  ansible_galaxy_command="ansible-galaxy role install -r '$ansible_requirements' -p '$ansible_roles' $ansible_force_roles_update"
  _echo "Installing Ansible Galaxy roles" 'a'
  eval "$ansible_galaxy_command" 1> "$dev_output"
}

function run_ansible_playbook {
  _echo "Running Ansible provisioning" 'a'
  # this is not wrapped with `execute` because
  # we want the script to keep going and run the cleanup tasks
  # even if an error occur during Ansible execution
  ansible-playbook "$ansible_playbook" -i "$ansible_inventory"
}

function ask_for_ansible_sudo_password {
  # temporarely store the password in cleartext in the environment
  # so it can be used by Ansible throughout the whole execution
  if [[ -z $ANSIBLE_BECOME_PASS ]]; then
        _echo "Requesting the admin password to be used for 'sudo' throughout the deployment process" 'a'
        read -r -p ">>>>>>>>>> Insert the current user password: " -s ansible_become_pass
        export ANSIBLE_BECOME_PASS="${ansible_become_pass}"
        printf "\n"
  else
        _echo "ANSIBLE_BECOME_PASS is already set"
  fi
}

function setup_python {
  if [[ $python_provider == 'pyenv' ]];then
    install_pyenv
    activate_pyenv
    install_pyenv_python
  elif [[ $python_provider == 'conda' ]];then
    install_conda
    activate_conda
  elif [[ $python_provider != 'none' ]]; then
    _echo "Unknow python provider '$python_provider'" 'e'
    exit 1
  fi
  export PYTHON_PROVIDER="$python_provider"
  _echo "PYTHON_PROVIDER: $PYTHON_PROVIDER"
  export PYTHON_ROOT="$python_root"
  _echo "PYTHON_ROOT: $PYTHON_ROOT"
  export PIP_CONFIG_FILE="$pip_config_file"
  _echo "PIP_CONFIG_FILE: $PIP_CONFIG_FILE"
}

function create_recovery_key {
  if [[ -f $tools_script_create_recovery_key ]];then
    _echo "Creating FileVaultMaster recovery key" 'a'
    _exec "$tools_script_create_recovery_key" "-d" "$certificates_path" "$@"
    _echo "FileVaultMaster created successfully!" 'r'
    _echo "Opening the certificates directory '$certificates_path' for review" 'a'
    open "$certificates_path"
  else
    _echo "The script '$tools_script_create_recovery_key' is not installed in './tools'." 'e'
    _echo "Run '$0 update tools' to install the latest version" 'e'
    exit 1
  fi
}

function export_preferences {
  if [[ -f $tools_script_export_system_preferences ]];then
    _echo "Exporting system preferences and dotfiles" 'a'
    _exec "$tools_script_export_system_preferences" "-d" "$preferences_path" "-m" "$tools_macprefs_path" "backup"
    _echo "Export successful!" 'r'
  else
    _echo "The script '$tools_script_export_system_preferences' is not installed in './tools'." 'e'
    _echo "Run '$0 update tools' to install the latest version" 'e'
    exit 1
  fi

}

function export_apps_lists {
  if [[ -f $tools_script_export_apps_lists ]];then
    _echo "Exporting lists for $*" 'a'
    _exec "$tools_script_export_apps_lists" "-d" "$lists_path" "$@"
    _echo "Export successful!" 'r'
  else
    _echo "The script '$tools_script_export_apps_lists' is not installed in './tools'." 'e'
    _echo "Run '$0 update tools' to install the latest version" 'e'
    exit 1
  fi
}

function export_apps_lists_and_preferences {
    export_preferences
    export_apps_lists "$@"
}

function cleanup_tasks {
  restore_path_permissions
  disable_passwordless_sudo
}

function list_profiles {
  _echo "$profiles_path" 'r' 1>&2
  _exec "find" "$profiles_path" "-maxdepth" "1" "-mindepth" "1" "-type" "directory" "-exec" "basename" "{}" "\\" ";"
}

function install_dependencies {
  install_brew
  if [[ $python_provider != 'none' ]]; then
    setup_python
    if [[ $reinstall_conda == 'yes' ]] || [[ $reinstall_pyenv == 'yes' ]]; then
      upgrade_pip
    fi
    install_pip_dependencies
    install_ansible_galaxy_roles
  fi
  print_execution_time "${start_time}"
}

function provision {
  _echo "Starting time $( date )" 'r'
  ask_for_ansible_sudo_password
  enable_passwordless_sudo
  check_install_path_permissions
  [[ -n $SPLINTER_BASE_PROFILE ]] && retrieve_profile "$SPLINTER_BASE_PROFILE"
  [[ -n $SPLINTER_ROLE_PROFILE ]] && retrieve_profile "$SPLINTER_ROLE_PROFILE"
  install_dependencies
  run_ansible_playbook
  cleanup_tasks
  _echo "Ending time $( date )" 'r'
  print_execution_time "${start_time}"
}

function action_export {
  action_option=$1; # fetch the action's option
  # Process package options
  case $action_option in
    '')
      _error "Missing option for action '$action'"
      exit 1
      ;;
    -*)
      _error "Invalid option '$action_option' for action '$action'"
      exit 1
      ;;
    preferences)
      [[ $verbose != "yes" ]] && quiet="yes"
      action_requested="export_preferences"
      ;;
    all)
      [[ $verbose != "yes" ]] && quiet="yes"
      action_requested="export_apps_lists_and_preferences"
      action_requested_options=("$@") # assign as an array
      ;;
    *)
      [[ $verbose != "yes" ]] && quiet="yes"
      action_requested="export_apps_lists"
      action_requested_options=("$@") # assign as an array
      ;;
    esac
}

function action_list {
  action_option=$1; # fetch the action's option
  # Process package options
  case $action_option in
    profiles)
      [[ $verbose != "yes" ]] && quiet="yes"
      action_requested="list_profiles"
      ;;
    '')
      _error "Missing option for action '$action'"
      exit 1
      ;;
    *)
      _error "Invalid option '$action_option' for action '$action'"
      exit 1
      ;;
    esac
}

function action_update {
  ansible_force_roles_update=''
  action_option="$1"; # fetch the action's option
  case $action_option in
    deps|dependencies)
      action_message="Will reinstall all the dependencies (Python and Ansible Galaxy roles)"
      ansible_force_roles_update='--force'
      reinstall_conda='yes'
      reinstall_pyenv='yes'
      action_requested="install_dependencies"
      ;;
    conda)
      action_message="Will reinstall the Conda Python environemnt"
      python_provider="conda"
      reinstall_conda='yes'
      action_requested="install_dependencies"
      ;;
    pyenv)
      action_message="Will reinstall the Pyenv Python environemnt"
      python_provider="pyenv"
      reinstall_pyenv='yes'
      action_requested="install_dependencies"
      ;;
    profiles)
      shift
      action_message="Will update the custom profiles"
      while getopts ":a:b:g:r:" profiles_setting; do
        case "$profiles_setting" in
          a)
            custom_profiles_repo_account="$OPTARG"
            ;;
          g)
            export CUSTOM_PROFILES_REPO="$OPTARG"
            ;;
          b|r)
            requested_profile="$OPTARG"
            ;;
          \?)
            _error "Action '$action $action_option': Invalid setting '-${OPTARG}'"
            exit 1
            ;;
          :)
            _error "Action '$action $action_option': setting '-${OPTARG}' is missing an argument"
            exit 1
            ;;
        esac
      done

      shift $(( OPTIND - 1 ))

      if [[ -n $* ]];then
        # if it is NOT empty it means it interrupted before evaluating all the parameters
        # becaue it encountered a unexpected param or arg
        _error "Provided unknow parameter: $1"
        exit 1
      fi
      if [[ -n $requested_profile ]];then
        action_requested="retrieve_profile"
        action_requested_options=("$requested_profile") # assigne as an array
      else
        action_requested="update_profiles"
      fi
      ;;
    roles|galaxy|ansible)
      action_message="Will reinstall all the Asnible Galaxy roles"
      ansible_force_roles_update='--force'
      action_requested="install_dependencies"
      ;;
    tools)
      action_message="Will update '$my_name' tools"
      action_requested="update_tools"
      ;;
    self|auto|splinter)
      action_message="Will update '$my_name'"
      action_requested="update_splinter"
      ;;
    '')
      _error "Missing option for action '$action'"
      exit 1
      ;;
    *)
      _error "Invalid option '$action_option' for action '$action'"
      exit 1
      ;;
  esac

  [[ -n $1 ]] && shift
  if [[ -n $* ]];then
    # if it is NOT empty it means it interrupted before evaluating all the parameters
    # becaue it encountered a unexpected param or arg
    _error "Invalid option '$1' for action '$action $action_option'"
    exit 1
  fi
}

function action_create {
  action_option="$1"; # fetch the action's option
  [[ -n $action_option ]] &&  shift
  case $action_option in
    filevault-recovery-key)
      [[ $verbose != "yes" ]] && quiet="yes"
      action_requested="create_recovery_key"
      action_requested_options=("$@") # assign as an array
    ;;
    package)
      action_message="Will create a provisioning package"
      while getopts ":d:n:t:" create_setting; do
        case $create_setting in
          d)
            package_destination="$OPTARG"
            ;;
          n)
            package_name="$OPTARG"
            ;;
          t)
            package_type="$OPTARG"
            ;;
          \?)
            _error "Action '$action $action_option': Invalid setting '-${OPTARG}'"
            exit 1
            ;;
          :)
            _error "Action '$action $action_option': setting '-${OPTARG}' is missing an argument"
            exit 1
            ;;
        esac
      done

      shift $(( OPTIND - 1 ))

      if [[ -n $* ]];then
        # if it is NOT empty it means it interrupted before evaluating all the parameters
        # becaue it encountered a unexpected param or arg
        _error "Provided unknow parameter: $1"
        exit 1
      fi
      action_requested="create_package"
      ;;
    '')
      _error "Missing option for action '$action'"
      exit 1
      ;;
    *)
      _error "Invalid option '$action_option' for action '$action'"
      exit 1
      ;;
  esac
}

function action_provision {
  while getopts ":a:c:b:f:g:h:p:r:t:u:" action_setting; do
    case "$action_setting" in
      a)
        custom_profiles_repo_account="$OPTARG"
        ;;
      c)
        splinter_config_file="$OPTARG"
        ;;
      b)
        export SPLINTER_BASE_PROFILE="$OPTARG"
        ;;
      f)
        export NEW_USER_FULL_NAME="$OPTARG"
        ;;
      g)
        export CUSTOM_PROFILES_REPO="$OPTARG"
        ;;
      h)
        export COMPUTER_HOST_NAME="$OPTARG"
        ;;
      p)
        export NEW_USER_PASSWORD_CLEARTEXT="$OPTARG"
        ;;
      r)
        export SPLINTER_ROLE_PROFILE="$OPTARG"
        ;;
      t)
        export TARGET_USER_ID="$OPTARG"
        ;;
      u)
        export NEW_USER_USERNAME="$OPTARG"
        ;;
      \?)
        _error "Action '$action': Invalid setting '-${OPTARG}'"
        exit 1
        ;;
      :)
        _error "Action '$action': setting '-${OPTARG}' is missing an argument"
        exit 1
        ;;
    esac
  done

  shift $(( OPTIND - 1 ))
  if [[ -n $* ]];then
    # if it is NOT empty it means it interrupted before evaluating all the parameters
    # becaue it encountered a unexpected param or arg
    _error "Provided unknow parameter: $1"
    exit 1
  fi
  action_requested="provision"
}

function main {
  quiet='no'
  verbose='no'
  case "$1" in
    -e|--env)
      python_provider="$2"
      shift 2
      ;;
    -v|--verbose)
      [[ $quiet != 'yes' ]] && verbose='yes'
      shift 1
      ;;
    -q|--quiet)
      [[ $verbose != 'yes' ]] && quiet='yes'
      shift 1
      ;;
    --help)
      show_usage
      exit 0
      ;;
    --version)
      show_version
      exit 0
      ;;
    -*)
      _error "Invalid option: $1"
      exit 1
      ;;
  esac


  action="$1";
  [[ -n $action ]] && shift 1
  case "$action" in
    create)
      verbose='yes' # `create` will always be verbose
      action_create "$@"
      ;;
    export)
      action_export "$@"
      ;;
    list)
      action_list "$1"
      ;;
    update)
      verbose='yes' # `update` will always be verbose
      action_update "$@"
      ;;
    provision)
      action_provision "$@"
      ;;
    '')
      _error "Missing action"
      exit 1
      ;;
    *)
      _error "Invalid action '$action'"
      exit 1
      ;;
  esac

  setup_environment
  [[ $quiet == 'no' ]] && show_title
  show_envs
  [[ -n $action_message ]] && _echo "$action_message" 'w'
  [[ -n $action_requested ]] && eval "$action_requested" "${action_requested_options[@]}" # read as an array
  exit 0
}

main "$@"
