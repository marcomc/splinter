#!/bin/bash
version="0.4-beta"
release_date="20200912"
config_dir=""
my_name="$(basename "${0}")"
start_time=$(date +%s)

ansible_force_roles_update=''

python_provider="conda"

pip_dependecies="
ansible
wheel
passlib
"
pip_show_grep_filter='Version'  # 'Name\|Version\|Location' - it's a grep filter

conda_package_name="splinter-conda.tar.gz"
conda_package_version="v0.1"
conda_package_url="https://github.com/marcomc/splinter-conda/releases/download/${conda_package_version}/${conda_package_name}"

desired_ansible_version='2.9.13'
desired_passlib_version='1.7.2'
desired_python_version='3.8.5'
desired_wheel_version='0.35.1'

homebrew_installer_url='https://raw.githubusercontent.com/Homebrew/install/master/install.sh'

pause_seconds='3'
staff_guid='20'

splinter_archive_url="https://github.com/marcomc/splinter/archive/master.zip"
splinter_tools_url="https://github.com/marcomc/splinter-tools/archive/master.zip"

function _exec {
  "$@" || { _echo "Failed during: ${*}" 'e'; exit 1; }
}

function _echo {
  purple="\e[35m"
  red="\e[31m"
  green="\e[32m"
  cyan="\e[36m"
  white="\e[39m"
  yellow="\e[33m"
  message_type=""
  output_device="/dev/stdin"
  case ${2} in
    a|action)
      colour="${cyan}" #green
      tag='ACTION..'
    ;;
    w|warning)
      colour="${yellow}"
      tag='WARNING.'
      message_type="warning"
      output_device="/dev/stderr"
      ;;
    e|error)
      colour="${red}"
      tag='ERROR...'
      message_type="error"
      output_device="/dev/stderr"
      ;;
    r|remark)
      colour="${purple}" #green
      tag='SPLINTER'
    ;;
    i|info|*)
      message_type="info"
      colour="${green}" #green
      tag='INFO....'
    ;;
  esac
  if [[ "${verbose}" == "yes" ]] || [[ "${message_type}" != "info" ]]; then
    if [[ "${quiet}" == "no" ]] || [[ "${message_type}" == "error" ]] || [[ "${message_type}" == "warning" ]]; then
      printf "${colour}[${tag}] ${white}%s\n" "${1}" > "${output_device}"
    fi
  fi
}

function show_version {
  echo "Splinter ${version} ${release_date}"
}

function show_title {
  cat << 'EOF'
   _______  _____         _____ __   _ _______ _______  ______
   |______ |_____] |        |   | \  |    |    |______ |_____/
   ______| |       |_____ __|__ |  \_|    |    |______ |    \_
        2020 (c) MarcMC - github.com/marcomc/splinter
An opinionated provisioning tool for macOS automated with Ansible

EOF
}


function show_usage {
printf  "usage: %s [option] action [object] [settings]\n" "${my_name}"
cat << 'EOF'

options:
       -e|--env conda|pyenv     List available profiles
       --help                   Print help\
       --version                Print Splinter version and release date

actions:
       list profiles            List available profiles
       provision [settings]     Provision the host\
       update <object>          Update the object

obejcts:
       conda                    Reinstall the most recent Miniconda Python environment available for splinter
       pyenv                    Reinstall Pyenv Python environment
       galaxy|galaxy-roles      Force update all the Ansible Galaxy roles
       tools                    Update the splinter tools
       deps|dependencies        Update all the dependencies (Python envs and  Ansible Galaxy role)
       self|auto|splinter       Update Splinter itself (but not the tools or dependencies)
       profiles settings

settings:
       [ provision ]
       -c file                  Specify a custom configuration file
       -b base_profile_name     Specify the the BASE profile to be used (default: 'default')
       -r role_profile_name     Specify the the ROLE profile to be used
       -u username              New user username (all lowercase  without spaces)
       -f 'Full Name'           New user full name (quoted if has blank spaces)
       -p 'cleartext password'  New user's password in cleartext (quoted if has blank spaces)
       -h Computer-Name         Computer host name no blank spaces allowed
       -q                       Suppress all non-Ansible output (except errors and warnings), is overriden with '-v'
       -v                       Produce verbose output

       [ provision, update profiles ]
       -a account_name          Specify the the Github account name for the custom `splinter-profiles` repo
       -g git-repo-name         Specify the the Github repository name for the custom `splinter-profiles` repo

EOF
  printf  "Create your own profiles in the '%s' directory.\n" "${profiles_path}"
  return 0
}

function show_envs {
  _echo "VERBOSE: ${VERBOSE}"
  [[ -n "${CUSTOM_CONFIG_FILE}" ]] && _echo "CUSTOM_CONFIG_FILE: ${CUSTOM_CONFIG_FILE}"
  [[ -n "${SPLINTER_CONFIG_DIR}" ]] && _echo "SPLINTER_CONFIG_DIR: ${SPLINTER_CONFIG_DIR}"
  [[ -n "${SPLINTER_BASE_PROFILE}" ]] && _echo "SPLINTER_BASE_PROFILE: ${SPLINTER_BASE_PROFILE}"
  [[ -n "${SPLINTER_ROLE_PROFILE}" ]] && _echo "SPLINTER_ROLE_PROFILE: ${SPLINTER_ROLE_PROFILE}"
  [[ -n "${CUSTOM_PROFILES_ACCOUNT}" ]] && _echo "CUSTOM_PROFILES_ACCOUNT: ${CUSTOM_PROFILES_ACCOUNT}"
  [[ -n "${CUSTOM_PROFILES_REPO}" ]] && _echo "CUSTOM_PROFILES_REPO: ${CUSTOM_PROFILES_REPO}"
  [[ -n "${COMPUTER_HOST_NAME}" ]] && _echo "COMPUTER_HOST_NAME: ${COMPUTER_HOST_NAME}"
  [[ -n "${NEW_USER_FULL_NAME}" ]] && _echo "NEW_USER_FULL_NAME: '${NEW_USER_FULL_NAME}'"
  [[ -n "${NEW_USER_PASSWORD_CLEARTEXT}" ]] && _echo "NEW_USER_PASSWORD_CLEARTEXT: ${NEW_USER_PASSWORD_CLEARTEXT}"
  [[ -n "${NEW_USER_USERNAME}" ]] && _echo "NEW_USER_USERNAME: ${NEW_USER_USERNAME}"
}

function print_execution_time {
  start_seconds="${1}"
  end_seconds=$(date +%s)
  total_seconds=$(( end_seconds - start_seconds ))
  total_minutes=$(( total_seconds / 60 ))

  if [[ ${total_minutes} -gt 0 ]]; then
    total="${total_minutes} minutes"
  else
    total="${total_seconds} seconds"
  fi
  _echo "Execution time was ${total}" 'r'
}

function set_app_directories {
  if [[ -z "${SPLINTER_CONFIG_DIR}" ]]; then
    if [[ -z "${config_dir}" ]]; then
      # assumes the directory that contains `splinter` is the Splinter directory
      config_dir="$(realpath "$(dirname "${0}")")"
    fi
    export SPLINTER_CONFIG_DIR="${config_dir}"
  else
    # makes sure that `config_dir` is assigned
    config_dir="${SPLINTER_CONFIG_DIR}"
  fi

  files_path="${SPLINTER_CONFIG_DIR}/files"
  tools_path="${SPLINTER_CONFIG_DIR}/tools"
  profiles_path="${SPLINTER_CONFIG_DIR}/profiles"
  ansible_dir="${SPLINTER_CONFIG_DIR}/ansible"
  pyenv_dir="${SPLINTER_CONFIG_DIR}/pyenv"
  conda_path="${SPLINTER_CONFIG_DIR}/conda"
  pip_config_file="${SPLINTER_CONFIG_DIR}/pip.conf"

  ansible_roles="${ansible_dir}/roles"
  ansible_config="${ansible_dir}/ansible.cfg"
  ansible_inventory="${ansible_dir}/inventory"
  ansible_playbook="${ansible_dir}/playbook.yml"
  ansible_requirements="${ansible_dir}/requirements.yml"
}

function update_splinter {
  _echo "Updating splinter" 'a'
  splinter_archive="${my_name}.zip"
  temp_dir=$(mktemp -d)

  _echo "Downloading Splinter into '${temp_dir}/${splinter_archive}'" 'a'
  _exec "curl" "-fsSL" "${splinter_archive_url}" "-o" "${temp_dir}/${splinter_archive}"

  _echo "Decompressing Splinter archive into '${temp_dir}'" 'a'
  _exec "unzip" "-qq" "${temp_dir}/${splinter_archive}" "-d" "${temp_dir}"
  ls "${temp_dir}"

  _echo "Installing Splinter files to '${config_dir}'" 'a'
  _exec "rsync" "-rlWuv" "${temp_dir}"/*/* "${config_dir}"

  _echo "Removing temporary files" 'a'
  _exec "rm" "-rf" "${temp_dir}"

  _echo "Update successful!" 'r'
}

function update_tools {
  _echo "Updating Splinter tools" 'a'
  splinter_tools_archive="${my_name}-tools.zip"
  temp_dir=$(mktemp -d)

  _echo "Downloading Splinter tools into '${temp_dir}/${splinter_tools_archive}'" 'a'
  _exec "curl" "-fsSL" "${splinter_tools_url}" "-o" "${temp_dir}/${splinter_tools_archive}"

  _echo "Decompressing Splinter tools into '${temp_dir}'" 'a'
  _exec "unzip" "-qq" "${temp_dir}/${splinter_tools_archive}" "-d" "${temp_dir}"
  ls "${temp_dir}"

  _echo "Installing Splinter tools to '${tools_path}'" 'a'
  _exec "rsync" "-rlWuv" "${temp_dir}"/*/* "${tools_path}"

  _echo "Removing temporary files" 'a'
  _exec "rm" "-rf" "${temp_dir}"

  _echo "Tools updated successfully!" 'r'
}

function update_profiles {
  if [[ "${VERBOSE}" == "no" ]]; then
    quiet_rsync="yes"
  else
    quiet_rsync=""
  fi
  profile_name="${1}"
  profile_to_single_out="${profile_name}"
  if [[ -n "${profile_name//[^.]/}" ]]; then
    # isolate the actual profile name located after the `.`
    profile_to_single_out="${profile_name#*"."}"
  fi

  if [[ -n "${CUSTOM_PROFILES_ACCOUNT}" ]]; then
    _echo "CUSTOM_PROFILES_ACCOUNT: ${CUSTOM_PROFILES_ACCOUNT} (detected)"
    account_name="${CUSTOM_PROFILES_ACCOUNT}"
  else
    _echo "Critical Error: this should never happen:" 'e'
    _echo "CUSTOM_PROFILES_ACCOUNT not defined althought we are cheking for a git repo" 'e'
    exit 1
  fi

  target_profile_name="${account_name}.${profile_to_single_out}"
  if [[ -n "${CUSTOM_PROFILES_REPO}" ]]; then
    _echo "CUSTOM_PROFILES_REPO: ${CUSTOM_PROFILES_REPO}"
    repository="${CUSTOM_PROFILES_REPO}"
  else
    repository="splinter-profiles";
  fi
  exclude_dir="files"
  splinter_profiles_source_site="https://www.github.com"
  splinter_profiles_archive="${account_name}-profiles.zip"
  splinter_profiles_url="${splinter_profiles_source_site}/${account_name}/${repository}/archive/master.zip"
  temp_dir=$(mktemp -d)

  _echo "Updating profiles and files from custom repository" 'a'

  _echo "Downloading custom profiles into '${temp_dir}/${splinter_profiles_archive}'" 'a'
  _exec "curl" "-fsSL" "${splinter_profiles_url}" "-o" "${temp_dir}/${splinter_profiles_archive}"

  _echo "Decompressing custom profiles into '${temp_dir}'" 'a'
  _exec "unzip" "-qq" "${temp_dir}/${splinter_profiles_archive}" "-d" "${temp_dir}"

  find "${temp_dir}"/* ! -path "*files" "-maxdepth" "1" "-mindepth" "1" -type directory -exec sh -c 'mv $1 "$(dirname $1)/$2.$(basename $1)"' -- {} "${account_name}" \;

  if [[ "${profile_to_single_out}" != "" ]]; then

    temp_profilepath="$(find "${temp_dir}" -type directory -name "${target_profile_name}")"

    if [[ -d "${temp_profilepath}" ]];then
      _echo "Installing custom profile '${target_profile_name}' to '${profiles_path}'" 'a'
      # _exec "cp" "-a" "${temp_profilepath}" "${profiles_path}/${target_profile_name}"
      _exec "rsync" "-rlWuv${quiet_rsync}" "--exclude" "${exclude_dir}" "${temp_profilepath}" "${profiles_path}/"
    else
      _echo "No profile '${target_profile_name}' found in '${splinter_profiles_url}'" 'e'
      exit 1
    fi
  else
    _echo "Installing custom profiles to '${profiles_path}'" 'a'
    _exec "rsync" "-rlWuv${quiet_rsync}" "--exclude" "${exclude_dir}" "${temp_dir}"/*/* "${profiles_path}"
  fi

  _echo "Installing custom files to '${files_path}'" 'a'
  _exec "rsync" "-rlWuv${quiet_rsync}" "${temp_dir}"/*/files/* "${files_path}"

  _echo "Removing temporary files" 'a'
  _exec "rm" "-rf" "${temp_dir}"

  _echo "Profiles updated successfully!" 'r'
}

function check_install_path_permissions {
  current_path=$(pwd -P)
  third_level_dir=$(echo "${current_path}" | cut -d'/' -f-4)
  dir_stats=$(stat -f '%N %g %p' "${third_level_dir}")
  read -ra DIR_STATS <<< "${dir_stats}"
  dir_name="${DIR_STATS[0]}"
  dir_group_id="${DIR_STATS[1]}"
  dir_pemissions="${DIR_STATS[2]:(-3)}"
  dir_group_pemissions="${DIR_STATS[2]:(-2):1}"

  if [[ "${current_path}" == "${HOME}"* ]]; then
    _echo 'You are running this script within your home directory' 'w'
    _echo 'Ansible might fail if your home directories are protected' 'w'
    _echo "(not allowing group memebers to 'read' AND 'exec' them)" 'w'
    _echo "Checking the permissions on the containing dir" 'a'
    _echo "DIR_NAME: ${dir_name}"
    _echo "dir_group_id: ${dir_group_id}"
    _echo "DIR_PEMISSIONS: ${dir_pemissions}"
    if [[ "${staff_guid}" != "${dir_group_id}" ]]; then
      _echo "The '${dir_name}' group is not 'staff(${staff_guid})'" 'w'
    elif [[ "${dir_group_pemissions}" -lt "5" || "${dir_group_pemissions}" -eq "6" ]]; then
      _echo "'${dir_name}' does NOT allow the 'staff' group to 'read' AND 'exec'" 'w'
      _echo "(this might lead to issues during the execution of some Ansible tasks)" 'w'
      _echo "Adding POSIX 'g+rx' permissions to ${third_level_dir}" 'a'
      _exec "chmod" "g+rx" "${third_level_dir}"
      export ORIGINAL_DIR_PEMISSIONS="${dir_pemissions}"
      export THIRD_LEVEL_DIR="${third_level_dir}"
    fi
    if [[ "${quiet}" == "no" ]]; then
      _echo "Pausing for ${pause_seconds} seconds for you to read the above message..." 'a'
      printf ">>>>>>>>> "
      for ((i=1; i<=pause_seconds; i++)); do
        # running the countdown before resuming operations
        printf "..%s" "${i}"
        sleep 1
      done
      printf "\n" # add newline after the countdown
    fi
  fi
}

function restore_path_permissions {
  if [ -n "${ORIGINAL_DIR_PEMISSIONS}" ] && [ -n "${THIRD_LEVEL_DIR}" ]; then
    _echo "Restoring original permissions '${ORIGINAL_DIR_PEMISSIONS}' to the directory '${THIRD_LEVEL_DIR}'" 'a'
    chmod "${ORIGINAL_DIR_PEMISSIONS}" "${THIRD_LEVEL_DIR}"
  fi
}

function profile_is_available {
  requested_profile="${1}"
  if [ -z "${requested_profile}" ]; then
    # if the paramater is empty just keep going
    # ansible will only load default configs
    _echo "No profile name has been provided" 'e'
    exit 1
  elif [[ ! -d "${profiles_path}/${requested_profile}" ]]; then
    # if the profile doesn't exist locally we will try to find it a git repo
    # take the fist part of the profile nale before the `.`
    if [[ -n "${requested_profile//[^.]/}" ]]; then
      # if the profile name is composed (contains a '.')
      export CUSTOM_PROFILES_ACCOUNT="${requested_profile%"."*}"
    fi

    if [[ -n "${CUSTOM_PROFILES_ACCOUNT}" ]]; then
      # if a git account has been provided look for it online
      eval update_profiles "${requested_profile}"
    else
      _echo "The profile '${requested_profile}' does not exist" 'e'
      exit 1
    fi
  fi
}

function enable_passwordless_sudo {
  sudo_stdin=''
  if sudo -n true 2>/dev/null; then
    _echo "Passwordless sudo is seems to be already available"
  else
    if [ -n "${ANSIBLE_BECOME_PASS}" ]; then
      sudo_stdin='--stdin'
    fi
    # Enable passwordless sudo for the provisioning
    _echo "Enabling passwordless sudo for the provisioning" 'a'
    echo "${ANSIBLE_BECOME_PASS}" | sudo "${sudo_stdin}" sed -i -e "s/^%admin (.*)ALL.*/%admin ALL=(ALL) NOPASSWD: ALL/" /etc/sudoers >/dev/null 2>&1
  fi
}

function disable_passwordless_sudo {
  if sudo -n true 2>/dev/null; then
    # Enable passwordless sudo for the provisioning
    _echo "Disabling passwordless sudo after the provisioning" 'a'
    sudo sed -i -e "s/^%admin (.*)ALL.*/%admin ALL=(ALL) ALL/" /etc/sudoers
  else
    _echo "Passwordless sudo is disabled"
  fi
}

function install_pip_dependencies {
  for pip_dependecy in ${pip_dependecies}; do
    if ! pip show "${pip_dependecy}" >/dev/null 2>&1; then
      _echo "${pip_dependecy} not installed" w
      eval "install_pip_${pip_dependecy}"
    else
      dep_version=$(pip show "${pip_dependecy}" | grep "${pip_show_grep_filter}")
      _echo "${pip_dependecy} ${dep_version} is installed "
    fi
  done
}

function install_brew {
  if ! command -v "brew" >/dev/null 2>&1; then
    _echo "Installing Homebrew" 'a'
    /bin/bash -c "$(curl -fsSL ${homebrew_installer_url})" < /dev/null
  else
    tool_version=$(command -v "brew")
    _echo "Homebrew ${tool_version} is installed"
  fi

}

function install_conda {
  conda_package_path="${files_path}/${conda_package_name}"
  if [[ "${reinstall_conda}" == "yes" ]];then
    if [[ -f "${conda_package_path}" ]]; then
      _echo "Removing old Miniconda Python package '${conda_package_path}'" 'a'
      _exec "rm" "${conda_package_path}"
    fi
    if [[ -d "${conda_path}" ]]; then
      _echo "Removing old Miniconda Python directory '${conda_path}'" 'a'
      _exec "rm" "-rf" "${conda_path}"
    fi
  fi
  if [[ ! -d "${conda_path}/bin" ]];then
    if [[ ! -f "${conda_package_path}" ]];then
      _echo "Downloading Miniconda Python package to '${conda_package_path}'" 'a'
      _exec "curl" "-fsSL" "${conda_package_url}" "-o" "${conda_package_path}"
    fi
    _echo "Unpacking Miniconda Python package to '${conda_path}' directory" 'a'
    _exec "mkdir" "-p" "${conda_path}"
    _exec "tar" "-xzf" "${conda_package_path}" "-C" "${conda_path}"
  else
    _echo "Miniconda Python package is already installed in '${conda_path}' directory" 'i'
  fi
}

function activate_conda {
  _echo "USING PROJECT'S OWN MINICONDA PYTHON VERSION" 'r'

  # Actual Conda activation
  python_root="${conda_path}"
  export _CONDA_ROOT="${conda_path}"
  export CONDA_PREFIX="${_CONDA_ROOT}"
  export PATH="${_CONDA_ROOT}/bin:$PATH"

  _echo "Cleanup prefixes from in the active environment"
  _exec "conda-unpack"

  python_version="$(python --version 2>&1)"
  _echo "${python_version} is installed"

  # Fix issues with SSL Certificates
  cert_path=$(python -m certifi)
  export SSL_CERT_FILE="${cert_path}"
  export REQUESTS_CA_BUNDLE="${cert_path}"
  _echo "SSL_CERT_FILE: ${cert_path}"
  _echo "REQUESTS_CA_BUNDLE: ${cert_path}"

}

function activate_pyenv {
  _echo "USING PROJECT'S OWN PYENV PYTHON VERSION" 'r'
  export PYENV_ROOT="${pyenv_dir}"
  export PATH="${PYENV_ROOT}/bin:${PATH}"
  export PYENV_VERSION="${desired_python_version}"
  python_root="${pyenv_dir}"
  _echo "PYENV_ROOT: ${PYENV_ROOT}"
  _echo "PYTHON_VERSION: $(pyenv version)"
}

function update_brew {
  _echo "Updating Homebrew" 'a'
  _exec "brew" "update"
}

function install_pyenv {
  if ! command -v "pyenv" >/dev/null 2>&1; then
    _echo "Installing Pyenv" 'a'
    # install pyenv with homebrew
    eval update_brew
    _exec "brew" "install" "pyenv"
  else
    tool_version=$(command -v "pyenv")
    _echo "Pyenv ${tool_version} is installed"
  fi
}

function install_pip_ansible {
  _echo "PIP - Installing Ansible ${desired_ansible_version}" 'a'
  _exec "pip" "install" "ansible==${desired_ansible_version}"
  # pip show ansible | grep "${pip_show_grep_filter}"
}

function install_pip_wheel {
  _echo "PIP - Installing Wheel ${desired_wheel_version}" 'a'
  _exec "pip" "install" "wheel==${desired_wheel_version}"
  # pip show "wheel"  | grep "${pip_show_grep_filter}"
}

function install_pip_passlib {
  _echo "PIP - Installing passlib ${desired_passlib_version}" 'a'
  _exec "pip" "install" "passlib==${desired_passlib_version}"
  # pip show "passlib" | grep "${pip_show_grep_filter}"
}

function install_pyenv_python {
  if [[ "${reinstall_pyenv}" == "yes" ]]; then
    if [[ -d "${pyenv_dir}" ]]; then
      _echo "Removing old Pyenv Python directory '${pyenv_dir}'" 'a'
      _exec "rm" "-rf" "${pyenv_dir}"
    fi
  fi
  if ! pyenv versions | grep "${desired_python_version}" >/dev/null 2>&1; then
    # â€¢	install python3 with pyenv
    _echo "Installing Pyenv Python ${desired_python_version}" 'a'
    _exec "pyenv" "install" "${desired_python_version}"
    _exec "ln" "-fs" "shims" "${pyenv_dir}/bin"
    _echo "Rehashing Pyenv Python shims ${desired_python_version}" 'a'
    _exec "pyenv" "rehash"
  else
    _echo "Pyenv Python ${desired_python_version} is already installed"
  fi
}

function upgrade_pip {
    _echo "Upgrading PIP to the latest version" 'a'
    _exec "pip" "install" "--upgrade" "pip"
}

function install_ansible {
  if ! command -v 'ansible' >/dev/null 2>&1; then
    _echo "Ansible not installed" w
    eval install_pip_ansible
  else
    _echo "Ansible is already installed"
    _exec "ansible" "--version"
  fi
}

function install_ansible_galaxy_roles {

  if [ "${verbose}" == "yes" ];then
    dev_output="/dev/stdout"
  else
    dev_output="/dev/null"
  fi
  ansible_galaxy_command="ansible-galaxy role install -r '${ansible_requirements}' -p '${ansible_roles}' ${ansible_force_roles_update}"
  _echo "Installing Ansible Galaxy roles" 'a'
  eval "${ansible_galaxy_command}" 1> "${dev_output}"
}

function run_ansible_playbook {
  _echo "Running Ansible provisioning" 'a'
  export ANSIBLE_CONFIG="${ansible_config}"
  _echo "ANSIBLE_CONFIG: ${ANSIBLE_CONFIG}"
  export ANSIBLE_ROLES_PATH="${ansible_roles}"

  # this is not wrapped with `execute` because if an error occur during Ansible execution we want the script to keep going and run the cleanup tasks
  ansible-playbook "${ansible_playbook}" -i "${ansible_inventory}"
}

function ask_for_ansible_sudo_password {
  # temporarely store the password in cleartext in the environment
  # so it can be used by Ansible throughout the whole execution
  if [ -z "${ANSIBLE_BECOME_PASS}" ]; then
        _echo "Requesting the admin password to be used for 'sudo' throughout the deployment process" 'a'
        read -r -p ">>>>>>>>> Insert the current user password: " -s ansible_become_pass
        export ANSIBLE_BECOME_PASS="${ansible_become_pass}"
        printf "\n"
  else
        _echo "'ANSIBLE_BECOME_PASS' is already set"
  fi
}

function setup_python {
  if [ "${python_provider}" == "pyenv" ];then
    eval install_pyenv
    eval activate_pyenv
    eval install_pyenv_python
  elif [ "${python_provider}" == "conda" ];then
    eval install_conda
    eval activate_conda
  else
    _echo "Unknow python provider '${python_provider}'" 'e'
    exit 1
  fi
  export PYTHON_PROVIDER="${python_provider}"
  _echo "PYTHON_PROVIDER: ${PYTHON_PROVIDER}"
  export PYTHON_ROOT="${python_root}"
  _echo "PYTHON_ROOT: ${PYTHON_ROOT}"
  export PIP_CONFIG_FILE="${pip_config_file}"
  _echo "PIP_CONFIG_FILE: ${PIP_CONFIG_FILE}"
}

function cleanup_tasks {
  eval restore_path_permissions
  eval disable_passwordless_sudo
}

function install_dependencies {
  if [[ "${action}" == "update" ]]; then
    eval show_title
    _echo "${update_message}" 'w'
    _echo "SPLINTER_CONFIG_DIR: ${SPLINTER_CONFIG_DIR}"
  fi
  eval install_brew
  eval setup_python
  if [[ "${reinstall_conda}" == "yes" ]] || [[ "${reinstall_pyenv}" == yes ]]; then
    eval upgrade_pip
  fi
  eval install_pip_dependencies
  eval install_ansible_galaxy_roles
  eval print_execution_time "${start_time}"
}

function provision {
  _echo "$(eval show_version)"
  _echo "Starting time $( date )" 'r'
  eval show_envs
  eval ask_for_ansible_sudo_password
  eval enable_passwordless_sudo
  eval check_install_path_permissions
  [[ -n "${SPLINTER_BASE_PROFILE}" ]] && eval profile_is_available "${SPLINTER_BASE_PROFILE}"
  [[ -n "${SPLINTER_ROLE_PROFILE}" ]] && eval profile_is_available "${SPLINTER_ROLE_PROFILE}"
  eval install_dependencies
  eval run_ansible_playbook
  eval cleanup_tasks
  _echo "Ending time $( date )" 'r'
  eval print_execution_time "${start_time}"
}

function main {
  verbose='no'
  quiet='no'
  eval set_app_directories
  # Parse options to the `install` command
  case "${1}" in
    -e|--env)
      python_provider="${2}"
      shift 2
      ;;
    --help)
      eval show_usage
      exit 0
      ;;
    --version)
      eval show_version
      exit 0
      ;;
    -*)
      echo "[Error] Invalid option: ${1}" 1>&2
      eval show_usage 1>&2
      exit 1
      ;;
  esac

  action="${1}";
  case "${action}" in
    list)
      action_option=$2; # fetch the action's option
      # Process package options
      _echo "OPTION: ${action_option}"
      case ${action_option} in
        profiles)
          _echo "${profiles_path}" 'r' 1>&2
          _exec "find" "${profiles_path}"  "-maxdepth" "1" "-mindepth" "1" "-type" "directory" "-exec" "basename" "{}" "\\" ";"
          ;;
        '')
          echo "[Error] Missing option for action '${action}'" 1>&2
          eval show_usage 1>&2
          exit 1
          ;;
        *)
          echo "[Error] Incorrect option '${action_option}' for action '${action}'" 1>&2
          eval show_usage 1>&2
          exit 1
          ;;
      esac
      ;;
    # Parse options to the install sub command
    update)
      action_option="${2}";# fetch the action's option
      # Process package options
      verbose='yes' # `update` will always be verbose

      shift
      case ${action_option} in
        deps|dependencies)
          update_message="Will reinstall all the dependencies (Python and Ansible Galaxy roles)"
          ansible_force_roles_update='--force'
          reinstall_conda='yes'
          reinstall_pyenv='yes'
          eval install_dependencies
          exit 0
          ;;
        conda)
          update_message="Will reinstall the Conda Python environemnt"
          python_provider="conda"
          reinstall_conda='yes'
          eval install_dependencies
          exit 0
          ;;
        pyenv)
          update_message="Will reinstall the Pyenv Python environemnt"
          python_provider="pyenv"
          reinstall_pyenv='yes'
          eval install_dependencies
          exit 0
          ;;
        profiles)
          shift
          update_message="Will update the custom profiles"
          while getopts ":a:g:" profiles_option; do
            case "${profiles_option}" in
              a)
                export CUSTOM_PROFILES_ACCOUNT="${OPTARG}"
                ;;
              g)
                export CUSTOM_PROFILES_REPO="${OPTARG}"
                ;;
              \?)
                echo "[Error] Action '${action} ${action_option}': Invalid setting '-${OPTARG}'" 1>&2
                eval show_usage 1>&2
                exit 1
                ;;
              :)
                echo "[Error] Action '${action} ${action_option}': setting '-${OPTARG}' is missing an argument" 1>&2
                eval show_usage 1>&2
                exit 1
                ;;
            esac
          done
          shift $(( OPTIND - 1 ))
          if [[ -n "${*}" ]];then
            # if it is NOT empty it means it interrupted before evaluating all the parameters
            # becaue it encountered a unexpected param or arg
            echo "[Error] Provided unknow parameter: ${1}" 1>&2
            eval show_usage 1>&2
            exit 1
          fi
          eval update_profiles
          ;;
        roles|galaxy|ansible)
          update_message="Will reinstall all the Asnible Galaxy roles"
          ansible_force_roles_update='--force'
          eval install_dependencies
          exit 0
          ;;
        tools)
          update_message="Will update '${my_name}' tools"
          eval update_tools
          exit 0
          ;;
        self|auto|splinter)
          update_message="Will update '${my_name}'"
          eval update_splinter
          exit 0
          ;;
        '')
          echo "[Error] Missing option for action '${action}'" 1>&2
          eval show_usage 1>&2
          exit 1
          ;;
        *)
          echo "[Error] Incorrect option '${action_option}' for action '${action}'" 1>&2
          eval show_usage 1>&2
          exit 1
          ;;
      esac
      _echo "OPTION: ${action_option}"
      ;;
    provision )
      shift
      while getopts ":a:c:b:f:g:h:p:r:u:qv" action_option; do
        case "${action_option}" in
          a)
            export CUSTOM_PROFILES_ACCOUNT="${OPTARG}"
            ;;
          c)
            export CUSTOM_CONFIG_FILE="${OPTARG}"
            ;;
          b)
            export SPLINTER_BASE_PROFILE="${OPTARG}"
            ;;
          f)
            export NEW_USER_FULL_NAME="${OPTARG}"
            ;;
          g)
            export CUSTOM_PROFILES_REPO="${OPTARG}"
            ;;
          h)
            export COMPUTER_HOST_NAME="${OPTARG}"
            ;;
          p)
            export NEW_USER_PASSWORD_CLEARTEXT="${OPTARG}"
            ;;
          q)
            [[ ! $verbose == 'yes' ]] && quiet='yes'
            ;;
          r)
            export SPLINTER_ROLE_PROFILE="${OPTARG}"
            ;;
          u)
            export NEW_USER_USERNAME="${OPTARG}"
            ;;
          v)
            verbose='yes'
            quiet='no'
            ;;
          \?)
            echo "[Error] Action '${action}': Invalid setting '-${OPTARG}'" 1>&2
            eval show_usage 1>&2
            exit 1
            ;;
          :)
            echo "[Error] Action '${action}': setting '-${OPTARG}' is missing an argument" 1>&2
            eval show_usage 1>&2
            exit 1
            ;;
        esac
      done

      shift $(( OPTIND - 1 ))
      if [[ -n "${*}" ]];then
        # if it is NOT empty it means it interrupted before evaluating all the parameters
        # becaue it encountered a unexpected param or arg
        echo "[Error] Provided unknow parameter: ${1}" 1>&2
        eval show_usage 1>&2
        exit 1
      fi

      export VERBOSE="${verbose}"
      [[ ${quiet} == "no" ]] && eval show_title
      eval provision
      ;;
    '')
      echo "[Error] Missing action" 1>&2
      eval show_usage 1>&2
      exit 1
      ;;
    *)
      echo "[Error] Invalid action '$action'" 1>&2
      eval show_usage 1>&2
      exit 1
      ;;
  esac
}
main "${@}"
